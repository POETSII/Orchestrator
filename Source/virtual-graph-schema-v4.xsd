<?xml version="1.0" encoding="UTF-8"?>
<!--


  This file is a <a href="http://relaxng.org/">RELAX NG</a> schema
  for defining POETS graph types and instances. This document
  is both the grammar specification, and the documentation of
  that specification.

  A RELAX NG grammar uses a BNF like description to constrain
  an XML document to particular patterns, allowing you to specify
  what kinds of elements and attributes can appear within each
  other, and how many of each are allowed/needed. It is
  essentially the same as using a YACC grammar, except
  no code generation is needed. There are existing tools for
  working with these grammers, which are able to take an
  XML document and check that it matches the grammar.

  ### Changes from version 0

  There are a few changes/additions since v0:
  - Edge properties and state are now defined on the input pin rather
    than the edge itself. This is based on looking at how Spinnaker
    does things, and some situations where some device types need
    different properties for input pins with the same device type.

  ### Changes from version 1

  Everything that was once a "port" is now a "pin".

  All XML files should have a Provenance element. This is still only loosely specified though,
  and needs to be refined.

  ### Changes from 2 -> 2.1

  PIP-0007 integrated

  ### Changes from 2.1 -> 2.2

  PIP-0004 integrated

  ### Changes from 2.2 -> 3.0
  For more information, see PIP-0017

  Optional OnInit handler added
  <S> tag added to DevI to allow individual setting of device instance states.
  Optional Default tag has been added to Scalar, Array, Tuple, and Union
  Optional attribute "indexed" in OutputPin added:
    Boolean used to indicate whether this pin broadcasts or sends to an index.
  Optional attribute "sendIndex" accepting an integer to identify this pin for indexed send Output pin
  Application pins removed
  DeviceSharedCode removed
  Fix incorrect definition for TypeDef (typedDataSpec -> typedDataMember)
  TypeDef can now contain documentation
  Dense or Sparse array initialisation provided for Arrays.
  Digest hashes for types and instances added
  Added <SupervisorType>, renamed from <SupervisorDeviceType> in previous versions.
  GraphInstance attribute "supervisorTypeId" changed from "supervisorDeviceTypeId"
  Updated SupervisorType to the specification discussed with Southampton
  <OnCompute> and <OnIdle> tags are to be entirely removed
    These are replaced by optional <OnHardwareIdle>, <OnDeviceIdle> and <OnThreadIdle>.
    This provides more detailed descriptions of when these handlers are executed


  ### Changes from 3 -> 4alpha

  - All ordering is explicit
  - All tags must appear, even if they are empty
  - Structs are defined using C
  - No documentation tags
  - Metadata tags are greatly restricted to be key-value pairs
  - No typedefs
  - One graph type per document
  - At most one graph instance per document
  - Anything that doesnt have defined semantics is removed.
-->
<!-- BEGIN_SCHEMA -->
<!--
  This section establishes some ambient declarations
  for the grammar

  This is used to bring in things like integers, as XML
  Schema doesn't support many primitive types.
-->
<!--
  This is the XML namespace within which the graphs live.
  If a breaking change is made to the graph specification,
  then the namespace identifier will change.
-->
<!-- Here begins the actual grammar itself -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="https://poets-project.org/schemas/virtual-graph-schema-v4" xmlns:v="https://poets-project.org/schemas/virtual-graph-schema-v4">
  <xs:simpleType name="identifier">
    <xs:annotation>
      <xs:documentation>All identifiers used in the graph types are simplified C
identifiers. This applies to type ids and instances ids.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-zA-Z0-9_]+"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:element name="Metadata">
    <xs:complexType>
      <xs:attribute name="key" use="required" type="xs:string"/>
      <xs:attribute name="value" use="required" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="Graphs">
    <xs:annotation>
      <xs:documentation>The top-level container can contain one graph type, and
zero or one graph instances.

The graph instance must referr to the graph type in the graph.

An example of a top-level graph, including xml pre-amble, would be:

   &lt;?xml version="1.0"?&gt;
   &lt;Graphs xmlns="https://poets-project.org/schemas/virtual-graph-schema-v4" formatMinorVersion="0"&gt;
     &lt;GraphType id="my_graph_type"&gt;
        ... &lt;!-- See GraphType --&gt;
     &lt;/GraphType&gt;
     &lt;GraphInstance id="my_graph_instance" graphTypeId="my_graph_type"&gt;
        ... &lt;!-- See GraphInstance --&gt;
     &lt;/GraphInstance&gt;
   &lt;/Graphs&gt;</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="v:GraphType">
          <xs:annotation>
            <xs:documentation>There is always one graph type</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element minOccurs="0" ref="v:GraphInstance">
          <xs:annotation>
            <xs:documentation>There may be one graph instance</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="formatMinorVersion" use="required">
        <xs:annotation>
          <xs:documentation>If non-breaking changes are made to the schema, the minor
version can be increased. The major version is explicit
in the namespace for the schema.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="0"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="GraphType">
    <xs:annotation>
      <xs:documentation>A graph type encapsulates the data-structures and handlers
associated with a particular kind of graph.

A graph type describes a space of possible graphs, and there
are a (usually) infinite set of possible graph instances
that could be created of that type.

A minimal graph type would be:

     &lt;GraphType id="example"&gt;
       &lt;Properties&gt;&lt;![CDATA[
         uint32_t haloSize;
         ]]&gt;float threshold;
       &lt;/Properties&gt;
       &lt;State&gt;&lt;![CDATA[
         uint32_t counter;
       ]]&gt;&lt;/State&gt;
       &lt;SharedCode&gt;&lt;![CDATA[
         inline int helper(int x) { return x+1; }
       ]]&gt;&lt;/SharedCode&gt;
       &lt;MessageTypes&gt;
         &lt;MessageType id="update"&gt;&lt;![CDATA[
           uint32_t update;
         ]]&gt;&lt;/MessageType&gt;
       &lt;/MessageTypes&gt;
       &lt;DevicesTypes&gt;
         ... &lt;!-- See DeviceType --&gt;
         ... &lt;!-- See ExternalType --&gt;
       &lt;/DeviceTypes&gt;
     &lt;/GraphType&gt;</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="v:Metadata"/>
        <xs:element name="Properties">
          <xs:annotation>
            <xs:documentation>Global properties that are shared with all nodes at run-time.</xs:documentation>
          </xs:annotation>
          <xs:complexType mixed="true">
            <xs:attribute name="cTypeName" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Used to specify what the C type name is for the properties structure.
The default is "{graphTypeId}_properties_t".

The explicit or implicit name will be available within the
graph handler code as ${GRAPH_PROPERTIES_T}.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="SharedCode" type="xs:string">
          <xs:annotation>
            <xs:documentation>C++ code that needs to be injected into the handler source
files.

Declarations at the graph level will be visible to
all devices in the graph, essentially by pre-pending them
before the handler code.

Multiple declarations are allowed, in which case they will
be inserted into the output in the same order as they appear
in the graph type.

The intent is that handlers don't need to link against
external code, so all functions should be included inline.
The base language is C++, so inline functions are legal.

An example of a shared code section would be:

   &lt;GraphType id="..."&gt;
     &lt;Properties&gt; ... &lt;/Properties
     &lt;SharedCode&gt;&lt;![CDATA[
       // Declare a shared helper function
       inline int cube(int x) { return x*x*x; }

       // Declare a function which calculates a function
       // of the the graph properties
       inline int graph_area(const GRAPH_PROPERTIES_T *gp)
       { return gp-&gt;width*gp-&gt;height; }
     ]]&gt;&lt;/SharedCode&gt;
     &lt;DeviceTypes&gt;
       ...
     &lt;/DeviceTypes&gt;
   &lt;/GraphType

This example makes use of the GRAPH_PROPERTIES_T macro
in order to avoid depending on the specific C type
name of the properties structure. By default the
name will be `${graphTypeId}_properties_t`, but that
can be customised using the `cTypeName` attribute.
The code is placed in a CDATA section to avoid
escaping problems. Otherwise a `&lt;` symbol in the
C code needs to be escaped to `&amp;lt;`.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element ref="v:MessageTypes"/>
        <xs:element ref="v:DeviceTypes"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>Unique identifier for the graph type.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="MessageTypes">
    <xs:annotation>
      <xs:documentation>Establishes the different types of message that could exist in the graph.

This element must exist, even if there are no message types.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="v:MessageType"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="MessageType">
    <xs:annotation>
      <xs:documentation>A message type captures a type of communication that could happen between pins

The reason for having named types is that messages can have semantic
meaning beyond their structural type. For example, empty messages are quite
common, but can indicate quite different things within a single graph type.
For example, the `reset` message and `trigger` message are both empty structs,
but should not be connected to each eother.

The ordering of message types has no semantic meaning, but the order should be
preserved when reading and writing graph types.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="v:Message"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>Must be unique amongst all message types</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="Message">
    <xs:annotation>
      <xs:documentation>The type of messages that are sent over this edge. This may be empty or not exist
(e.g. if it is only a pulse).</xs:documentation>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="cTypeName" type="v:identifier">
        <xs:annotation>
          <xs:documentation>Used to specify what the C type name is for the message structure.
The default is "{graphTypeId}_{messageTypeId}_message_t".

The actual type name will be available within send/receive handlers as ${MESSAGE_T}.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="DeviceTypes">
    <xs:annotation>
      <xs:documentation>This establishes the shapes of devices, though not the internals.

This element must exist (a graph with no devices is not useful).</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="v:DeviceType"/>
        <xs:element ref="v:ExternalType"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="DeviceType">
    <xs:annotation>
      <xs:documentation>A device type captures a piece of structure and functionality that can
be instantiated within the graph. All devices of the same type are identical
except for the functionality they have.

The number of pins must be fixed, but we allow a variable number of
edges to enter or leave a pin. Alongside the edge properties and
edge state this provides storage that scales with the number of edges.

Messages are delivered to the device in any order, and a device has no
way of avoiding receipt of messages.

Each output pin and the compute pin of the device are given a unique
non-negative "requestIndex". The requestIndex will be contiguous and start at zero.
so they can be used as bit-field masks. The maximum number of output pins + compute
pin is fixed at 32, in order to bound memory requirements at one word per device.

For an output pin called {name}, the requestIndex will be available within
handlers and device shared code as `RTS_INDEX_{name}`, and the
equivalent bit-mask as `RTS_FLAG_{name}`.
These values will be injected as C++ identifiers
when the handler code is compiled, so for different devices there will be
different identifiers in scope.

Flags are also available globally through a flag of the form:
`RTS_FLAG_{device_type}_{name}` and `RTS_INDEX_{device_type}_{name}`.
This allows for the use of flags outside device scope (sometimes it
is useful to work with them in the graph shared code, but it is difficult
to work out what numbers they will have).

TODO (2019/06/30,dt10): Why is the graph type not includes in flag names?
Or conversely, why is graph type included in struct names?
</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Properties">
          <xs:annotation>
            <xs:documentation>Read-only properties that could be specified on the device. This element
may not appear if the device has no properties. There may be default
values specified for some or all components of the properties.</xs:documentation>
          </xs:annotation>
          <xs:complexType mixed="true">
            <xs:attribute name="cTypeName" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Used to specify what the C type name is for the properties structure.
The default is "{graphTypeId}_{deviceTypeId}_properties_t".

The properties type will be available within handlers as DEVICE_PROPERTIES_T</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="State">
          <xs:annotation>
            <xs:documentation>Mutable properties attached to the device. In principle this element might
not appear, if the device has no state (I suppose all the mutable state could
be in the edge properties).</xs:documentation>
          </xs:annotation>
          <xs:complexType mixed="true">
            <xs:attribute name="cTypeName" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Used to specify what the C type name is for the state structure.
The default is "{graphTypeId}_{deviceTypeId}_state_t".

The state type will be available within handlers as DEVICE_STATE_T</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="SharedCode" type="xs:string"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="InputPin">
          <xs:annotation>
            <xs:documentation>An input pin that appears on the device type.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Properties">
                <xs:annotation>
                  <xs:documentation>Indicates read-only properties associated with each edge. This will be
delivered along-side messages which arrive along that edge
An input pin may have no properties, in which case this element will not exist.</xs:documentation>
                </xs:annotation>
                <xs:complexType mixed="true">
                  <xs:attribute name="cTypeName" type="v:identifier">
                    <xs:annotation>
                      <xs:documentation>Used to specify what the C type name is for the properties structure.
The default is "{graphTypeId}_{deviceTypeId}_{pinName}_properties_t".

The properties type will be available within handlers as PORT_PROPERTIES_T</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="State">
                <xs:annotation>
                  <xs:documentation>Indicates mutable state associated with an edge.</xs:documentation>
                </xs:annotation>
                <xs:complexType mixed="true">
                  <xs:attribute name="cTypeName" type="v:identifier">
                    <xs:annotation>
                      <xs:documentation>Used to specify what the global C type name is for the properties structure.
The default is "{graphTypeId}_{deviceTypeId}_{pinName}_state_t".

The properties type will be available within handlers as ${PORT_STATE_T}</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element ref="v:OnReceive"/>
            </xs:sequence>
            <xs:attribute name="name" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Name of the pin, must be unique within the device type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="messageTypeId" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Identifies the message type for this pin
A pin can only be connected to an output of the same type (not just structurally,
they must have the same messageTypeId)</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="OutputPin">
          <xs:annotation>
            <xs:documentation>An output pin that appear on the device type.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="v:OnSend"/>
            </xs:sequence>
            <xs:attribute name="name" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Name of the pin, must be unique within the device type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="indexed" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This is an indicator of whether this output pin performs an "Indexed Sends" PIP-0002
If so, then the message produced will be able to send to a single device based on index
Optional attribute: default is implicit false</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="messageTypeId" use="required" type="xs:string">
              <xs:annotation>
                <xs:documentation>Identifies the message type for this pin.

A pin can only be connected to a pin of the same type (not just structurally,
they must have the same messageTypeId)</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element ref="v:ReadyToSend"/>
        <xs:element ref="v:OnInit"/>
        <xs:element ref="v:OnHardwareIdle"/>
        <xs:element minOccurs="0" ref="v:OnDeviceIdle"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>Must be unique amongst all device types</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="OnReceive" type="xs:string">
    <xs:annotation>
      <xs:documentation>Event handler for when a message arrives on this device. The body will
be a fragment of C. It should probably be wrapped in a CDATA section,
but that is up to you. The code should be a statement or sequence of
statements, and does not contain any function header.

Rationale: why a fragment? It forces the implementer to not use globals etc.,
and means we have control over the type names of the various structs.

TODO (2019/06/30, dt10) : Why are these PORT_PROPERTIES_T, shouldn't it be PIN_PROPERTIES_T?

Variables which will be in scope are:
  `const ${GRAPH_PROPERTIES_T} *graphProperties` : Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device state
  `${DEVICE_STATE_T} *deviceState : Mutable pointer to the device state
  `const ${PORT_PROPERTIES_T} *edgeProperties` : Read-only pointer to the edge state
  ${PORT_STATE_T} *edgeState : Mutable pointer to the edge state
  `const ${MESSAGE_T} message : Read-only pointer to the message payload</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OnSend" type="xs:string">
    <xs:annotation>
      <xs:documentation>Event handler for sending a message on this device. The body will
be a fragment of C. It should probably be wrapped in a CDATA section.

The things which will be available within scope are:

  `const ${GRAPH_PROPERTIES_T} *graphProperties` :  Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device properties
  `${DEVICE_STATE_T} *deviceState` : Mutable pointer to the device state
  `${MESSAGE_T} *message` : A mutable pointer to payload associate with the edge
  `bool *doSend` : A mutable pointer to control whether the message is sent. By default it is true.
  `unsigned *sendIndex : If this output pin uses indexed sends, then this identifies which pin to send on.

Non-indexed pins should no assum sendIndex exists.
Indexed pins must modify sendIndex if doSend remains true.</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ReadyToSend" type="xs:string">
    <xs:annotation>
      <xs:documentation>Used to determine which output pins are ready to send.

This fragment returns a bit-mask indicating which pins currently
want to send,

The things which will be available within scope are:

  `const ${GRAPH_PROPERTIES_T} *graphProperties` :  Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device properties
  `const ${DEVICE_STATE_T} *deviceState` : Read-only pointer to the device state
  `uint32_t *readyToSend` : Used to specify the bit-mask indicating which pins want
                        to send. This will be initialised to zero.
  `bool *requestIdle` : Indicates whether the device wishes to do OnDeviceIdle computation when there is
                        idle compute time. This will be initialised to false.</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OnInit" type="xs:string">
    <xs:annotation>
      <xs:documentation>Code to run on the device before any other handler runs (this replaces the
old __init__ pin).
The things which will be available within scope are:

  `const ${GRAPH_PROPERTIES_T} *graphProperties` :  Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device properties
  `${DEVICE_STATE_T} *deviceState` : Read-write pointer to the device state

If the init handler is not presence it should implicitly have an empty body (though an
implementation can optimise that out).</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OnHardwareIdle" type="xs:string">
    <xs:annotation>
      <xs:documentation>Code which runs when the hardware detects that all of the following are true:
- all devices have empty RTS sets (i.e. no-one wants to send); and
- no devices have requestIdle true (i.e. no-one wants to compute); and
- no messages are in flight.
The hardware provides a signal to all device to run this handler.

An empty OnHardwareIdle is legal, and means the device simply moves
over the global barrier without being aware of it.

If all OnHardwareIdle handlers are empty, an implementation may omit the
OnHardwareIdle machinery (as this is not detectible/visible by the application).
Similarly the machinery may be selectively removed for certain device types,
as long as this does not change execution semantics.

The things which will be available within scope are:

  `const ${GRAPH_PROPERTIES_T} *graphProperties` :  Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device properties
  `${DEVICE_STATE_T} *deviceState` : Mutable pointer to the device state</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="OnDeviceIdle" type="xs:string">
    <xs:annotation>
      <xs:documentation>This event handler will execute when all of the following are true:
- there are no messages to be received on this device; and
- the device cannot currently send (either it doesn't want to, or there is no network space); and
- the device has set requestIdle to true in `readyToSend`

Note that the inability to receive does _not_ mean that there are no messages
en-route this device; similarly, the ability to send is not purely governed by
the device's desire to send. As a consequence, a call to OnDeviceIdle can be
arbitrarily interleaved with sends and receives by the platform. So from the
the application writer's point of view, a more useful statement is:

  This event handler may be called at any time when requestIdle is high.

As a consequence application writers should be very wary of holding requestIdle
high for long periods of time: device idle computation on one thread may stop
other threads making progress and sending or receiving messages. For an unfair
(but legal) softswitch this might result in livelock.

The things which will be available within scope are:

  `const ${GRAPH_PROPERTIES_T} *graphProperties` :  Read-only pointer to the graph properties
  `const ${DEVICE_PROPERTIES_T} *deviceProperties` : Read-only pointer to the device properties
  `${DEVICE_STATE_T} *deviceState` : Mutable pointer to the device state</xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="ExternalType">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Properties">
          <xs:annotation>
            <xs:documentation>Indicates read-only properties associated with an external instance.
This is useful to embed in the graph as it can be used to tell externals
what type of thing they should be, e.g. to configure frame-rate for a video,
or describe protocol properties such as the buffer depth of a native device
they are connected to. So it's a bit more than meta-data, as it does actually
change how the application operates, just not in a way that is known to the
standard tools.</xs:documentation>
          </xs:annotation>
          <xs:complexType mixed="true">
            <xs:attribute name="cTypeName" type="v:identifier"/>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="InputPin">
          <xs:complexType>
            <xs:attribute name="name" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Name of the pin, must be unique within the device type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="messageTypeId" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Identifies the message type for this pin
A pin can only be connected to an output of the same type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="OutputPin">
          <xs:complexType>
            <xs:attribute name="name" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Name of the pin, must be unique within the device type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="indexed" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This is an indicator of whether this output pin performs an "Indexed Sends" PIP-0002
If so, then the message produced will be able to send to a single device based on index
Optional attribute: default is implicit false</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="messageTypeId" use="required" type="v:identifier">
              <xs:annotation>
                <xs:documentation>Identifies the message type for this pin
A pin can only be connected to an output of the same type</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>An ExternalType defines external devices which connect external I/O to regular devices.
Unlike DeviceType ExternalType devices do not have state, properties, or handlers.
They only have input and output pins with no handlers attached.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="GraphInstance">
    <xs:annotation>
      <xs:documentation>This specifies an instance of a graph, including all the devices (nodes)
and edges between devices.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="v:Metadata"/>
        <xs:element ref="v:DeviceInstances"/>
        <xs:element ref="v:EdgeInstances"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="v:identifier"/>
      <xs:attribute name="graphTypeId" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>The graph type must have already been declared using either a GraphType or a GraphTypeReference</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="P">
        <xs:annotation>
          <xs:documentation>Read-only data associated with the entire graph</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="DeviceInstances">
    <xs:annotation>
      <xs:documentation>Zero or more DeviceInstance elements.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="v:DevI"/>
        <xs:element ref="v:ExtI"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="DevI">
    <xs:annotation>
      <xs:documentation>Each DevI creates a single device instance of a given device type.

Every device instance must have a unique id within the set
of devices instances. The exact nature of this identifier
is application-specific, and there is no requirement on string
length
</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>A unique string</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="type" use="required" type="xs:string">
        <xs:annotation>
          <xs:documentation>Links to a previously declared device type</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="P">
        <xs:annotation>
          <xs:documentation>Read-only properties associated with this device instance.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="S">
        <xs:annotation>
          <xs:documentation>This element is used to set the state of a deviceInstance instead of setting
a value through Device Properties, and using the init handler to set the state</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="ExtI">
    <xs:annotation>
      <xs:documentation>Each ExtI creates a single external device instance of a given external type.

Every external instance must have a unique id within the set
of all devices instances. The exact nature of this identifier
is application-specific, and there is no requirement on string
length
</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="id" use="required" type="v:identifier">
        <xs:annotation>
          <xs:documentation>A unique string</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="type" use="required" type="xs:string">
        <xs:annotation>
          <xs:documentation>Links to a previously declared device type</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="P">
        <xs:annotation>
          <xs:documentation>Read-only properties associated with this device instance.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="EdgeInstances">
    <xs:annotation>
      <xs:documentation>Zero or more edge instance elements</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="v:EdgeI"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="EdgeI">
    <xs:annotation>
      <xs:documentation>Each EdgeI specifies a single connection between two device instances.

The messageTypeId can be inferred from the types of the pins.
It is intended that the loader type-checks them against each
other, so it is not specified here.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="path">
        <xs:annotation>
          <xs:documentation>A string of the form "dstDeviceId:dstPinName-srcDeviceId:srcPinName"
It is legal for the dstDeviceId to be missing, in which case it will
connect to the supervisor device. Similarly srcDeviceId can be missing,
and will connect to the supervisor. Both cannot be missing, as that
would connect from a supervisor output to a supervisor input, but
a supervisor only exists in the context of devices being managed.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:pattern value="[_a-zA-Z0-9]*:[_a-zA-Z0-9]+-[_a-zA-Z0-9]*:[_a-zA-Z0-9]+"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="sendIndex" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Used in conjunction with "indexed" attribute in OutputPin
This indicates the index used to identify this edge only to send a message on</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="P">
        <xs:annotation>
          <xs:documentation>Read-only properties associated with the destination (input pin) of the edge instance</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="S">
        <xs:annotation>
          <xs:documentation>Mutable properties associated with the destination (input pin)
of this edge instance.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <!--
    TODO: improve text for v4

    Typed Data Specifications
    =========================

    It represents the prototype for a typed piece of data, along with
    the default values. The intent is that typed data is used for
    everything managed by P-Cores and send over the P-Core network,
    so typed data is explicitly fixed-size. It also needs to be
    writeable and readable by high-level tools, so the structure
    needs to be explicitly defined - we can't just use raw bytes
    everywhere.

    Typed-data is intended to be binary compatible across all native
    platforms, requiring zero marshalling. But we also need simulation
    platforms to be able to bring that raw binary data into their world
    (e.g. for Python, Haskell, JavaScript). In order to ensure this, we have
    to think about:
    - Cross compiler compatibility, making sure that all the platforms
      end up with exactly the same layout.
    - Alignment requirements on certain platforms. x86-64, ARM, and RISC-V all
      support unaligned reads, but if we want to do MIPS/NIOS/MBlaze then
      they are more complicated. The compiler can sort it out, but it will
      be slower.
    - Performance versus padding. If we pad out to give performance for
      the x64-64, it is likely to just be wasting space (memory and cache)
      on the RISC-V.
    - Bit-wise packing. We are likely to really care about bit-field packing
      for some messages and data structures.

    One possibility would be to use ASN.1 to define the structures,
    as this is a well-established method for describing data-structures,
    allowing fine-grain control over formatting. However it is mainly
    designed for messages on the wire, rather than data-structures
    that are manipulated directly (although it can be used for either).
    It also adds another tool-chain, and manipulating ASN.1 requires
    toolchains and libraries that aren't available in all platforms - there
    are JavaScript ASN.1 libraries around, but they didn't look that
    robust. Haskell and Python have good libraries though.


    Note: this is a historical comment from older versions. This is
    what we decided on in the end, so it becomes the responsibility
    of clients to parse the C declaration.

    > We could also embed the C declaration directly in this file,
    > then rely on the consumer to parse it out. The obvious down-side
    > is that every platform/language then needs a C structure parser,
    > and we would have to create some method of explicitly specifying
    > packing (though `#pragma pack(1)` is pretty portable).
    > The layout of bit-fields is also [implementation defined](http://en.cppreference.com/w/cpp/language/bit_field),
    > so we really can't rely on the compilers for all the different
    > CPUs and OSs doing the same thing.

    Historical note, this approach is no longer in use:

    > The approach taken here is to describe C structures directly
    > as part of the DOM, as everyone already has an XML parser. The
    > conversion process to a C struct or binary format is then
    > mandated by this specification.

    In order to eliminate surprises, the approach taken is that
    the ordering given by the designer mandates the layout in
    memory. This means that the designer has to take complete
    responsibility for getting good packing, but they can also
    do weird pointer-tricks if they really want to.

    For bit-fields, we want to allow them, but don't want
    complicated padding/alignment. I (DBT) cannot see a portable
    way of defining bit-fields that will end up the same
    on all architectures - these things aren't even defined by the
    compiler, it's [down to the ABI](https://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit-fields-implementation.html).
    The only way I could see to support this is to indicate that
    a scalar integer is actually split into bit-fields, but not
    to try to express them as C bit-fields. That way we would get complete
    control over the layout, and high-level tools can still
    extract the fields. The downside is that the bit-fields have
    to have associated accessor functions to get and set the values.

    So for now, bit-fields are not supported.

    Note: unions are removed as part of v4 to simplify. They may be brought
    back at some point:

    Begin not true
    // We support unions, as space is important for both messages and
    // storage, but must also have the ability to interpret a structure
    // at run-time (e.g. for debuggers and visualisation). So unions
    // are tagged unions, with the tag value representing which of the
    // alternatives is active.
    End not true

    So the rules are:
    - Every type has a size in bytes
    - The size of an integer or float is its natural size (e.g. uint32_t is 4, half is 2, uint64_t is 8)
    - All data-structures are laid out in the order specified in the C type specification
    - The size of a tuple is the sum of the size of the elements, laid out end to end
    - The size of an array is the size of the element multiplied by the array length

    There is no boolean type, because it does not have a natural platform-portable
    size. It is suggested to use an `int8_t` for performance, or a bit-field for size.

    Structures are specified as a list of C variable declarations. It must
    always be possible to parse a data-spec in isolation, without referring
    to any SharedCode segments or other fragments of C.
    Structures must be PODs (Plain old data-types), and can only consist of:
    - Scalars of basic specified-width int and float types
    - structs
    - fixed-size arrays
    - C or C++ style comments

    Given a spec, it should always be compileable as C given the following
    fragment:

    ```
    #include <stdint.h>

    #pragma pack(1)
    struct x{
       ${THE_TYPED_DATA_SPEC_STRING}
    };

    #include #include <type_traits>
    static_assert(std::is_pod<x>::value, "Struct is not a POD.");
    ```
    (It should be plain C, the C++ is just to get the definition of POD).
  -->
  <!-- Here endeth the grammar -->
</xs:schema>
<!-- END_SCHEMA -->
