//------------------------------------------------------------------------------

#include "CommonBase.h"
#include "Environment.h"
#include "mpi.h"
#include "PMsg_p.hpp"
#include "Pglobals.h"
#include <stdio.h>
#include "Unrec_t.h"

#include <string>
using namespace std;
typedef unsigned char byte;
const string CommonBase::S00 = string();

//==============================================================================

CommonBase::CommonBase(int argc,char ** argv,string d,string src)
{
//MPI_Init(&argc,&argv);               // Start up MPI
MPI_Init_thread(&argc,&argv,MPI_THREAD_MULTIPLE,&MPI_provided);

const int SNDBUFSIZ = 1000000000;      // MPI immediate message send buffer size
char * SNDBUF = (char *)malloc(SNDBUFSIZ);             // Pull it off the heap
if (SNDBUF!=0) MPI_Buffer_attach(SNDBUF,SNDBUFSIZ);    // Attach it to MPI
pPmap = new ProcMap(this);             // Create universe process map
                                       // Load event handler map
FnMapx[Msg_p::KEY(Q::EXIT                )] = &CommonBase::OnExit;
FnMapx[Msg_p::KEY(Q::PMAP                )] = &CommonBase::OnPmap;
FnMapx[Msg_p::KEY(Q::SYST,Q::PING,Q::ACK )] = &CommonBase::OnSystPingAck;
FnMapx[Msg_p::KEY(Q::SYST,Q::PING,Q::REQ )] = &CommonBase::OnSystPingReq;
FnMapx[Msg_p::KEY(Q::TEST,Q::FLOO        )] = &CommonBase::OnTestFloo;

Sderived = d;                          // Derived class name
Ssource = src;                         // Derived class source file name

Prologue(argc,argv);                   // Start MPI, build process map.....

}

//------------------------------------------------------------------------------

CommonBase::~CommonBase()
{
//printf("********* CommonBase rank %d destructor\n",Urank); fflush(stdout);
delete pPmap;
int idummy;                            // Clean up MPI immediate message buffer
void *SNDBUF;
MPI_Buffer_detach(&SNDBUF,&idummy);    // (Blocks until exhausted)
free(SNDBUF);                          // Now we can kill it
MPI_Finalize();
}

//------------------------------------------------------------------------------

void CommonBase::Dump(FILE * fp)
{
fprintf(fp,"CommonBase+++++++++++++++++++++++++++++++++++\n");
fprintf(fp,"Sderived (this derived process) : %s\n",Sderived.c_str());
fprintf(fp,"Event handler table:\n");
fprintf(fp,"Key        Method\n");
WALKMAP(unsigned,pMeth,FnMapx,i)
  fprintf(fp,"%#010x 0x%#010p\n",(*i).first,(*i).second);
fprintf(fp,"S00 (const static)              : %s\n",S00.c_str());
fprintf(fp,"Urank                           : %d\n",Urank);
fprintf(fp,"Usize                           : %d\n",Usize);
fprintf(fp,"Ulen                            : %d\n",Ulen);
fprintf(fp,"Sproc                           : %s\n",Sproc.c_str());
fprintf(fp,"UBPW                            : %u\n",UBPW);
fprintf(fp,"Scompiler                       : %s\n",Scompiler.c_str());
fprintf(fp,"SOS                             : %s\n",SOS.c_str());
fprintf(fp,"Ssource                         : %s\n",Ssource.c_str());
fprintf(fp,"Sbinary                         : %s\n",Sbinary.c_str());
fprintf(fp,"STIME                           : %s\n",STIME.c_str());
fprintf(fp,"SDATE                           : %s\n",SDATE.c_str());
if (pPmap==0) fprintf(fp,"No process map\n");
else pPmap->Dump(fp);
fprintf(fp,"CommonBase-----------------------------------\n\n");
fflush(fp);
}

//------------------------------------------------------------------------------

void CommonBase::MPISpinner()
// Spinner to handle ALL incoming MPI packets. There is only one exit from this:
// Decode() returns 1 when an "exit" command is detected.
{
int MSGBUFSIZ = 1024;                  // Individual incoming message buffer
char * MSGBUF = new char[MSGBUFSIZ];   // Pull it off the heap
for (;;) {
// See if there are any MPI packets coming down the pipe
  MPI_Status status;                   // Note the multi-threaded MPI probe
  int flag;
//MPI_Message message;
//MPI_Improbe(MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&flag,&message,&status);
  MPI_Iprobe(MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&flag,&status);
  if (flag==0) {                       // Nothing there....
    OnIdle();                          // Guess
    continue;                          // And try again
  }
  int count;
  MPI_Get_count(&status,MPI_CHAR,&count);
//  printf("MPISpinner: %d bytes coming\n",count);  fflush(stdout);
//  vector<char> buf(count+1);
  if (count > MSGBUFSIZ) {             // Ensure we have the space for it
    delete [] MSGBUF;                  // Throw the too-small one away
    MSGBUF = new char[MSGBUFSIZ=count+1]; // Pull a new (bigger) one off the heap
  }
//  printf("MPISpinner: buf has %u elements\n",buf.size());  fflush(stdout);
  MPI_Request request;
//  MPI_Imrecv(&buf[0],count,MPI_CHAR,&message,&request);
  MPI_Irecv(&MSGBUF[0],count,MPI_CHAR,MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&request);
//  printf("MPISpinner: waiting...\n");  fflush(stdout);
  int i=0;
  do { i++; MPI_Test(&request,&flag,&status); } while (flag==0);
//  printf("MPISpinner: after %d, %s has landed\n",i,&buf[0]);  fflush(stdout);
  PMsg_p Pkt((byte *)&MSGBUF[0],count);// Turn it into a packet
  Pkt.Ztime(1,MPI_Wtime());            // Timestamp arrival
  if (Decode(&Pkt)!=0) break;          // Do it, possibly leaving afterwards
}
//printf("********* CommonBase MPIspinner rank %d on the way out\n",Urank); fflush(stdout);
// Here iff Decode() found an "exit" command

if (MSGBUF!=0) delete [] MSGBUF;       // Kill the individual message buffer
}

//------------------------------------------------------------------------------

unsigned CommonBase::OnExit(PMsg_p * Z)
// Do not post anything further here - the LogServer may have already gone
{
//printf("(%s)::CommonBase::OnExit \n",Sderived.c_str());    fflush(stdout);
return 1;
}

//------------------------------------------------------------------------------

void CommonBase::OnIdle()
{

}

//------------------------------------------------------------------------------

unsigned CommonBase::OnPmap(PMsg_p * Z)
{
pPmap->Register(Z);                    // Load one element into the process map
return 0;
}

//------------------------------------------------------------------------------

unsigned CommonBase::OnSystPingAck(PMsg_p * Z)
// Ping acknowledge?
{
int cnt;
double ZT0 = 0.0;                      // MPI times
double * pZT0 = Z->Get<double>(0,cnt); // Unload the REQ launch time
if (pZT0!=0) ZT0 = *pZT0;
double trip = Z->Ztime(1)-ZT0;         // Round trip time
int * pTgtR = Z->Get<int>(0,cnt);      // Unload target rank
int TgtR;                              // Target rank
if (pTgtR!=0) TgtR = * pTgtR;
string TgtS = pPmap->M[TgtR];          // Target name
const unsigned len = 20;               // Process name length
TgtS.resize(len,' ');                  // So they line up on the console
string Fr(Sderived);
Fr.resize(len,' ');
unsigned * pu = Z->Get<unsigned>(4,cnt);// Ping attempt
Post(21,uint2str(*pu),Fr,int2str(Urank),TgtS,int2str(Z->Src()),dbl2str(trip));
return 0;
}

//------------------------------------------------------------------------------

unsigned CommonBase::OnSystPingReq(PMsg_p * Z)
{
unsigned * pu;
int cnt;
double ZT0,ZT1;                        // MPI times
PMsg_p Pkt(*Z);                        // Build response on top of incomer
Pkt.L(2,Q::ACK);                       // Sending it back....
ZT0 = Z->Ztime(0);                     // Copy MPI wallclock times over
ZT1 = Z->Ztime(1);
Pkt.Put<double>(0,&ZT0);
Pkt.Put<double>(1,&ZT1);
pu = Z->Get<unsigned>(4,cnt);          // Ping attempt
if (pu!=0) Pkt.Put<unsigned>(4,pu);
Pkt.Tgt(Z->Src());                     // Back to sender
/* Qt whinges about the following 2 lines - doesn't like taking the
   address of a temporary. Presumably it is being more strict about
   compliance with standards. In any case, this means annoyingly creating
   2 silly extra string objects just to get their addresses.
   Pkt.Put(4,&string(GetDate()));       // Payload
   Pkt.Put(5,&string(GetTime()));
*/
string tD(GetDate());
string tT(GetTime());
Pkt.Put(4,&tD);         // Payload
Pkt.Put(5,&tT);
Pkt.Put<int>(0,&Urank);                // My (sending) rank. Why, Lord?
Pkt.Src(Urank);                        // My sending rank.
Pkt.Send();
return 0;
}
//------------------------------------------------------------------------------

unsigned CommonBase::OnTestFloo(PMsg_p * Z)
// Got a test flood event.
{
static unsigned stop = 0;              // Some statistices
static unsigned sent = 0;
int c;
unsigned lev = *(Z->Get<unsigned>(2,c));// Extract remaining level
//printf("CommonBase::OnTest rank %u (coming) level %u\n",Urank,lev);  fflush(stdout);
if (lev==0) {                           // If we're done...
  stop++;
  Post(54,Sderived,uint2str(Urank),uint2str(stop),uint2str(sent));
  return 0;
}
--lev;

//printf("CommonBase::OnTest rank %u (middling) level %u\n",Urank,lev);  fflush(stdout);

Z->Put<unsigned>(2,&lev,1);              // No, decrement the level

//lev = *(Z->Get<unsigned>(2,c));
//printf("CommonBase::OnTest rank %u (going) level %u\n",Urank,lev);  fflush(stdout);

unsigned * pw = Z->Get<unsigned>(1,c);   // Extract burst width
sent += *pw;                             // Cumulative send count
for (unsigned i=0;i<*pw;i++) Z->Bcast(); // Send it on its way
return 0;
}

//------------------------------------------------------------------------------

bool CommonBase::Post(int i,
  string s00,string s01,string s02,string s03,string s04,string s05,string s06)
// Ideally we want a variable length argument list of std::strings, but the
// draft C++ standard section 5.2.2 Function call paragraph 7 clause 9:
// ...if the argument has a non-POD class type, the behavior is undefined...
// Which means we can have a list of strings but we can't tell when the list is
// empty.
// So I thought I'd use char * as the dummy arguments, but the type promotion in
// the compiler happily downconverts string() actuals to char *, but va_arg()
// chokes on it, so no joy there.
// So we do it the clunky way.
// When we did this for BIMPA, Post *belonged* to the Log class, but here it
// just *talks* to it.
{
vector<string> varg;
if (!s00.empty())varg.push_back(s00);
if (!s01.empty())varg.push_back(s01);
if (!s02.empty())varg.push_back(s02);
if (!s03.empty())varg.push_back(s03);
if (!s04.empty())varg.push_back(s04);
if (!s05.empty())varg.push_back(s05);
if (!s06.empty())varg.push_back(s06);
return Post(i,varg);
}

//------------------------------------------------------------------------------

bool CommonBase::Post(int i,vector<string> & varg)
// The other way into Post() - see above
{
if (Urank==Q::NAP)              throw (Unrec_t(1,Sderived,"Post"));
if (pPmap->U.LogServer==Q::NAP) throw (Unrec_t(2,Sderived,"Post"));
PMsg_p Pkt;
Pkt.PutX(1,&varg);
Pkt.Put<int>(1,&i);
Pkt.Key(Q::LOG,Q::POST);
Pkt.Src(Urank);
Pkt.Send(pPmap->U.LogServer);
// We always return true so we can write things like ....if(Post(...))return;...
return true;
}

//------------------------------------------------------------------------------

void CommonBase::Prologue(int argc,char ** argv)
// Startup code for EVERY orchestrator process.
{
MPI_Comm_size(MPI_COMM_WORLD,&Usize);  // Universe size
MPI_Comm_rank(MPI_COMM_WORLD,&Urank);  // My place within it
char Uname[MPI_MAX_PROCESSOR_NAME];
MPI_Get_processor_name(Uname,&Ulen);   // Machine name
Sproc = string(Uname);                 // Translated from the original FORTRAN

int * io_chan;
int   io_flag;                         // Establish who has IO
MPI_Attr_get(MPI_COMM_WORLD,MPI_IO,&io_chan,&io_flag);

UBPW = BPW();                          // ... bits per word
Scompiler = GetCompiler();             // ... compiler
SOS = GetOS();                         // ... Operating system
Sbinary = string(argv[0]);             // ... binary file
STIME = string(__TIME__);              // ... compilation time
SDATE = string(__DATE__);              // ... compilation date

PMsg_p Pkt;                            // Shove it all into a packet:
Pkt.Put<int>(1,&Urank);                // Load my rank...
Pkt.Put(2,&Sproc);                     // ... processor name
Pkt.Put(3,&Sderived);                  // ... C++ class
Pkt.Put<unsigned>(4,&UBPW);            // ... bits per word
Pkt.Put(5,&Scompiler);                 // ... compiler
Pkt.Put(6,&SOS);                       // ... operating system
Pkt.Put(7,&Ssource);                   // ... source file
Pkt.Put(8,&Sbinary);                   // ... binary file
Pkt.Put(9,&STIME);                     // ... compilation time
Pkt.Put(10,&SDATE);                    // ... compilation date
Pkt.Put<int>(11,&MPI_provided);        // ... MPI thread class
Pkt.Key(Q::PMAP);                      // Message key
Pkt.Src(Urank);
                                       // Build process map
//printf("%s:CommonBase about to send ProcMap records\n",Sderived.c_str());
//fflush(stdout);                      // Tell everyone else
for(int p=0;p<Usize;p++) if (p!=Urank) Pkt.Send(p);
pPmap->Register(&Pkt);                 // Need to put ourselves in seperately
//printf("%s:CommonBase at barrier\n",Sderived.c_str()); fflush(stdout);
MPI_Barrier(MPI_COMM_WORLD);           // Wait until everyone has told everyone
//printf("%s:CommonBase through barrier\n",Sderived.c_str()); fflush(stdout);
}

//==============================================================================


